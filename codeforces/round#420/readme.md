# Codeforces Round #420

## A. Okabe and Future Gadget Laboratory
给一个数组，问数组里面除了1以外的数是否都可以用同行和同列各一个数相加得到

### 解法
暴力遍历即可，简单题

## B. Okabe and Banana Trees
给一个方程，y = -x/m + b; 在该斜线与x, y轴的三角区域内选择一个矩形，使得矩形里的每个点(x,y), 
x1+y1 + x2+y2 + x3+y3 + ... + xn+yn最大，输出最大值。

### 解法
由题可知，矩形一定包含了原点(0,0),因为如果不包含的话，完全可以使矩形扩展到包含原点而使得值更大。
设右上角的点为(x,y),那么结果为：(x+1)*(y+1)*(x+y)/2, 而x = m(b-y), 枚举0<=y<=b，得到x,
然后取最大值即可.


## C. Okabe and Boxes
有n个数字，给2n个操作，操作有两种，分别为：
1. add(x),忘栈里增加数字x, 
2. remove, 从栈里取出当前最小的数字。
而被操作者可以对栈里的数字任何时刻进行排序，问一共需要排序几次，使得最后取出的值为1.2.3....n.

### 解法
维护一个当前为排序的栈即可，每次remove判断当前栈顶是否为要求的数字，如果不是则排序，是则取出。\

## D. Okabe and City
给一个1e4*1e4的矩形，其中最多有1e4个点是亮的（称之为初始亮），并且(1,1)一定是亮的，现在主角要从左上角走到右下角，
但是要保证只能走有亮光的路，当主角站在一个初始亮点，主角可以话费1使任意一行或者任意一列全部变亮，但是之前主角变亮的都要
变成原本的状态，问主角最多话费多少可以到达右下角，如果不能，输出－1.

### 解法
**最短路问题**, 给多有初始亮建立边，可以发现，只有最多相差2行或者两列的点可以建立边，并且如果不是相邻的点，花费都是1，
相邻的点花费是0，这样，如果右下角的点是初始亮，那么答案为d[右下角点的标号], 否者，从n,n-1行和m,m-1列找d[]最小的初始
亮＋1即为答案. 不用实际地建边，直接在找最短路的过程中只找能建边的那些点即可.